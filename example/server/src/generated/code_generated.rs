// This is an autogenerated file. DO NOT EDIT

#![allow(dead_code)]
use warp::Filter;
use serde::ser::SerializeTuple;


/// AUTOGENERATED. The struct that serializes error states
#[derive(Debug, Clone)]
pub struct ZetroServerError {
	/// Arbitrary, human-readable message for the end user
	pub message: String,
	/// Arbitrary, response code for frontend logic
	pub code: i16,
}

impl warp::reject::Reject for ZetroServerError {}

/// Contains basic information about a single message author
#[derive(Debug, Clone)]
pub struct AuthorRef {
	/// Username of author
	pub username: String,
}

impl serde::ser::Serialize for AuthorRef {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.username)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for AuthorRef {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = AuthorRef;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let username = seq.next_element::<String>()?;
				if username.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let username = username.unwrap();

				Ok(AuthorRef {
					username: username,
				})
			}
		}
		deserializer.deserialize_tuple(1, Visitor)
	}
}

/// Resembles a single chat room
#[derive(Debug, Clone)]
pub struct Chatroom {
	/// Unique id for this room
	pub id: u64,
	/// Messages in this room
	pub messages: Vec<Message>,
	/// Name of room
	pub name: String,
	pub status: RoomStatus,
}

impl serde::ser::Serialize for Chatroom {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.id)?;
		state.serialize_element(&self.messages)?;
		state.serialize_element(&self.name)?;
		state.serialize_element(&self.status)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for Chatroom {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = Chatroom;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let id = seq.next_element::<u64>()?;
				if id.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let id = id.unwrap();

				let messages = seq.next_element::<Vec<Message>>()?;
				if messages.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let messages = messages.unwrap();

				let name = seq.next_element::<String>()?;
				if name.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let name = name.unwrap();

				let status = seq.next_element::<RoomStatus>()?;
				if status.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let status = status.unwrap();

				Ok(Chatroom {
					id: id,
					messages: messages,
					name: name,
					status: status,
				})
			}
		}
		deserializer.deserialize_tuple(4, Visitor)
	}
}

/// Parameters for a GetRooms request
#[derive(Debug, Clone)]
pub struct GetRoomsRequest {
	/// Fetch only rooms with the given status
	pub with_status: Option<RoomStatus>,
}

impl serde::ser::Serialize for GetRoomsRequest {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.with_status)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for GetRoomsRequest {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = GetRoomsRequest;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let with_status = seq.next_element::<Option<RoomStatus>>()?;
				if with_status.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let with_status = with_status.unwrap();

				Ok(GetRoomsRequest {
					with_status: with_status,
				})
			}
		}
		deserializer.deserialize_tuple(1, Visitor)
	}
}

/// Returns the chat rooms
#[derive(Debug, Clone)]
pub struct GetRoomsResponse {
	/// A list of rooms
	pub rooms: Vec<Chatroom>,
}

impl serde::ser::Serialize for GetRoomsResponse {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.rooms)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for GetRoomsResponse {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = GetRoomsResponse;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let rooms = seq.next_element::<Vec<Chatroom>>()?;
				if rooms.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let rooms = rooms.unwrap();

				Ok(GetRoomsResponse {
					rooms: rooms,
				})
			}
		}
		deserializer.deserialize_tuple(1, Visitor)
	}
}

/// Resembles a single chat message in a room
#[derive(Debug, Clone)]
pub struct Message {
	/// Author who sent this message
	pub author: AuthorRef,
	/// UNIX timestamp (seconds) of when this message was sent
	pub date: u32,
	/// Unique id for this message
	pub id: u64,
	/// Message content
	pub text: String,
}

impl serde::ser::Serialize for Message {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.author)?;
		state.serialize_element(&self.date)?;
		state.serialize_element(&self.id)?;
		state.serialize_element(&self.text)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for Message {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = Message;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let author = seq.next_element::<AuthorRef>()?;
				if author.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let author = author.unwrap();

				let date = seq.next_element::<u32>()?;
				if date.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let date = date.unwrap();

				let id = seq.next_element::<u64>()?;
				if id.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let id = id.unwrap();

				let text = seq.next_element::<String>()?;
				if text.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let text = text.unwrap();

				Ok(Message {
					author: author,
					date: date,
					id: id,
					text: text,
				})
			}
		}
		deserializer.deserialize_tuple(4, Visitor)
	}
}

/// Parameters for a SendMessage request
#[derive(Debug, Clone)]
pub struct SendMessageRequest {
	/// The message to send. ID field is ignored.
	pub msg: Message,
	/// Room to send the message in
	pub room_id: u64,
}

impl serde::ser::Serialize for SendMessageRequest {
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
	where S: serde::ser::Serializer,
	{
		let mut state = serializer.serialize_tuple(2)?;
		state.serialize_element(&self.msg)?;
		state.serialize_element(&self.room_id)?;
		state.end()    
	}
}

impl<'de> serde::de::Deserialize<'de> for SendMessageRequest {
fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where D: serde::Deserializer<'de>,
	{
		struct Visitor;
		impl<'de> serde::de::Visitor<'de> for Visitor {
			type Value = SendMessageRequest;

			fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
				write!(formatter, "")
			}

			fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
			where A: serde::de::SeqAccess<'de>,
			{
				let msg = seq.next_element::<Message>()?;
				if msg.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let msg = msg.unwrap();

				let room_id = seq.next_element::<u64>()?;
				if room_id.is_none() {
					return Err(serde::de::Error::custom("invalid field"));
				}
				let room_id = room_id.unwrap();

				Ok(SendMessageRequest {
					msg: msg,
					room_id: room_id,
				})
			}
		}
		deserializer.deserialize_tuple(2, Visitor)
	}
}

#[derive(Debug, Copy, Clone, PartialEq, serde_repr::Serialize_repr, serde_repr::Deserialize_repr)]
#[repr(u8)]
pub enum RoomStatus {
	Active = 0,
	Disabled = 1,
}

pub struct ZetroContext {
	data: fnv::FnvHashMap<std::any::TypeId, Box<dyn std::any::Any + Sync + Send>>,
}

impl ZetroContext {
	pub fn new() -> Self {
		ZetroContext {
			data: fnv::FnvHashMap::default(),
		}
	}

	pub fn insert<T>(&mut self, item: T)
	where T: std::any::Any + Sync + Send,
	{
		self.data.insert(std::any::TypeId::of::<T>(), Box::new(item));
	}
    
	pub fn get<T>(&self) -> &T
	where T: std::any::Any + Sync + Send,
	{
		self.data
			.get(&std::any::TypeId::of::<T>())
			.unwrap()
			.downcast_ref::<T>()
			.unwrap()
		}
}

fn _generate_data_reply(data: Vec<serde_json::Value>) -> warp::reply::Response {
	let serialized = serde_json::to_string(&(
		&data,
		&serde_json::Value::Null,
	))
	.unwrap();

	warp::http::Response::builder()
		.status(200)
		.body(warp::hyper::body::Body::from(serialized))
		.unwrap()
}

fn _generate_error_reply(code: i16, message: &str) -> warp::reply::Response {
	let serialized = serde_json::to_string(&(
		&serde_json::Value::Null,
		&(&code, message),
		))
		.unwrap();

	warp::http::Response::builder()
		.status(200)
		.body(warp::hyper::body::Body::from(serialized))
		.unwrap()
}

#[async_trait::async_trait]
pub trait ZetroQueries {
	async fn get_rooms<'a>(ctx: &'a ZetroContext, request: GetRoomsRequest) -> Result<GetRoomsResponse, ZetroServerError>;
}

#[async_trait::async_trait]
pub trait ZetroMutations {
	async fn send_message<'a>(ctx: &'a ZetroContext, request: SendMessageRequest) -> Result<u64, ZetroServerError>;
}

pub fn generate_routes<Q, M>(ctx: ZetroContext, _queries: Q, _mutations: M) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone
where Q: ZetroQueries, M: ZetroMutations,
{
        use std::sync::Arc;

        let ctx = Arc::new(ctx);

        warp::any()
            .and(warp::any().map(move || Arc::clone(&ctx)))
            .and(warp::body::bytes())
            .then(|ctx: Arc<ZetroContext>, body: bytes::Bytes| async move {
                let mut retval: Vec<serde_json::Value> = Vec::new();
                let request_payload = serde_json::from_slice::<(u8, Vec<serde_json::Value>)>(&body);
                if request_payload.is_err() {
                    return _generate_error_reply(400, "Bad request");
                }
                // Determines whether the request is a query or mutation
                let (method_code, operations) = request_payload.unwrap();
                for op in operations {
                    if !op.is_array() {
                        return _generate_error_reply(400, "Operations must be an array");
                    }
                    let arr = op.as_array().unwrap();
                    let route_name = arr.get(0);
                    let route_body = arr.get(1);

                    if route_name.is_none() || route_body.is_none() {
                        return _generate_error_reply(400, "Route name and route body are mandatory");
                    }

                    let route_name = route_name.unwrap();
                    let route_body = route_body.unwrap().to_owned();

                    if !route_name.is_string() {
                        return _generate_error_reply(400, "Route name must be string");
                    }
                    let route_name = route_name.as_str().unwrap();
                    if method_code == 1 {
                        // Handle query
                        retval.push(match route_name {
                            
                        // 'GetRooms' route:
                        "YiGepyIChwIjKAW1XFFbSD-DH-4" => {
                            let route_body = serde_json::from_value::<GetRoomsRequest>(route_body);
                            if route_body.is_err() {
                                return _generate_error_reply(400, "Bad request");
                            }
                            let route_body = route_body.unwrap();
                            let result = Q::get_rooms(&ctx, route_body).await;
                            match result {
                                Err(e) => return _generate_error_reply(e.code, &e.message),
                                Ok(d) => serde_json::to_value((route_name, &d)).unwrap()
                            }
                        }
    
                            _ => {
                                return _generate_error_reply(400, "Unrecognized route name");
                            }
                        });
                    } else if method_code == 2 {
                        // Handle mutation
                        retval.push(match route_name {
                            
                        // 'SendMessage' route:
                        "89dG-t_0BkXmKSZq7mRDCYHXbBo" => {
                            let route_body = serde_json::from_value::<SendMessageRequest>(route_body);
                            if route_body.is_err() {
                                return _generate_error_reply(400, "Bad request");
                            }
                            let route_body = route_body.unwrap();
                            let result = M::send_message(&ctx, route_body).await;
                            match result {
                                Err(e) => return _generate_error_reply(e.code, &e.message),
                                Ok(d) => serde_json::to_value((route_name, &d)).unwrap()
                            }
                        }
    
                            _ => {
                                return _generate_error_reply(400, "Unrecognized route name");
                            }
                        });
                    } else {
                        return _generate_error_reply(400, "Bad request");
                    }
                }
                _generate_data_reply(retval)
            })
        }