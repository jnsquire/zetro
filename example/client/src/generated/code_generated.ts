// This is an autogenerated file. DO NOT EDIT

/** AUTOGENERATED
The struct that serializes error states */
export interface ZetroServerError {
	/** Arbitrary, human-readable message for the end user */
	message: string,
	/** Arbitrary, response code for frontend logic */
	code: number,
}

/* ============ Structs ============ */

/** Contains basic information about a single message author */
export interface AuthorRef {
	/** Username of author */
	username: string,
}

export function serializeAuthorRef(obj: AuthorRef): any[] | null {
	return [
		obj.username
	];
}

export function deserializeAuthorRef(obj: any): AuthorRef | null {
	if (obj == null) { return null; }
	return {
		username: obj[0]
	};
}

/** Resembles a single chat room */
export interface Chatroom {
	/** Unique id for this room */
	id: number,
	/** Messages in this room */
	messages: Message[],
	/** Name of room */
	name: string,
	status: number,
}

export function serializeChatroom(obj: Chatroom): any[] | null {
	return [
		obj.id,
		obj.messages.map(function (nested) { return serializeMessage(nested); }),
		obj.name,
		obj.status
	];
}

export function deserializeChatroom(obj: any): Chatroom | null {
	if (obj == null) { return null; }
	return {
		id: obj[0],
		messages: obj[1].map(function (elem: any) { return deserializeMessage(elem); }),
		name: obj[2],
		status: obj[3]
	};
}

/** Parameters for a GetRooms request */
export interface GetRoomsRequest {
	/** Fetch only rooms with the given status */
	withStatus?: number,
}

export function serializeGetRoomsRequest(obj: GetRoomsRequest): any[] | null {
	return [
		obj.withStatus
	];
}

export function deserializeGetRoomsRequest(obj: any): GetRoomsRequest | null {
	if (obj == null) { return null; }
	return {
		withStatus: obj[0]
	};
}

/** Returns the chat rooms */
export interface GetRoomsResponse {
	/** A list of rooms */
	rooms: Chatroom[],
}

export function serializeGetRoomsResponse(obj: GetRoomsResponse): any[] | null {
	return [
		obj.rooms.map(function (nested) { return serializeChatroom(nested); })
	];
}

export function deserializeGetRoomsResponse(obj: any): GetRoomsResponse | null {
	if (obj == null) { return null; }
	return {
		rooms: obj[0].map(function (elem: any) { return deserializeChatroom(elem); })
	};
}

/** Resembles a single chat message in a room */
export interface Message {
	/** Author who sent this message */
	author: AuthorRef,
	/** UNIX timestamp (seconds) of when this message was sent */
	date: number,
	/** Unique id for this message */
	id: number,
	/** Message content */
	text: string,
}

export function serializeMessage(obj: Message): any[] | null {
	return [
		serializeAuthorRef(obj.author),
		obj.date,
		obj.id,
		obj.text
	];
}

export function deserializeMessage(obj: any): Message | null {
	if (obj == null) { return null; }
	return {
		author: deserializeAuthorRef(obj[0]),
		date: obj[1],
		id: obj[2],
		text: obj[3]
	};
}

/** Parameters for a SendMessage request */
export interface SendMessageRequest {
	/** The message to send. ID field is ignored. */
	msg: Message,
	/** Room to send the message in */
	roomId: number,
}

export function serializeSendMessageRequest(obj: SendMessageRequest): any[] | null {
	return [
		serializeMessage(obj.msg),
		obj.roomId
	];
}

export function deserializeSendMessageRequest(obj: any): SendMessageRequest | null {
	if (obj == null) { return null; }
	return {
		msg: deserializeMessage(obj[0]),
		roomId: obj[1]
	};
}

/* ============ End Structs ============ */

/* ============ Enums ============ */

export const RoomStatus = {
	ACTIVE: 1,
	DISABLED: 2
} as const;

/* ============ End Enums ============ */

/** Users must implement this interface to use `ZetroQuery` and `ZetroMutation` */
export interface IZetroClient {
	/**
	 * Body is array-encoded data for the request. The return value MUST be the
	 * response JSON body of the server. Implementors can add authentication
	 * information to the request. This interface can be easily mocked for tests.
	 * Note that a non-200 response status (even in the case of a malformed request)
	 * MUST be considered an unexpected error and be handled accordingly.
	 * In other words, only forward the parsed JSON body to this method if the
	 * status is 200 OK.
	 */
	makeRequest: (body: any) => Promise<any>;
}

/* ============ Queries ============ */

export class ZetroQuery<T = unknown> {
	private state_: any[] = [];
	private parsers_: ((returnObject: any, item: any) => void)[] = [];
	private readonly client_: IZetroClient;

	constructor(client: IZetroClient) {
		this.client_ = client;
	}

	getRooms(requestBody: GetRoomsRequest): ZetroQuery<T & {getRooms: GetRoomsResponse}> {
		this.state_.push(["YiGepyIChwIjKAW1XFFbSD-DH-4", serializeGetRoomsRequest(requestBody)]);
		this.parsers_.push(function (resultObj: any, item: any) {
			resultObj.getRooms = deserializeGetRoomsResponse(item[1]);
		})
		return this as any;
	}

/*
 * Excecutes the request and returns the response.
 * If the call was unsuccessful, an error of type ZetroServerError
 * will be thrown.
 */
	async fetch(): Promise<T> {
		try {
			const result = await this.client_.makeRequest([1, this.state_]);
			if (result[1] != null) {
				// Error
				throw {code: result[1][0], message: result[1][1]}
			}
			const data = result[0];
			const returnObject = {};
			for (let i = 0; i < data.length; i++) {
				this.parsers_[i](returnObject, data[i]);
			}
			return returnObject as any;
		} catch (e) {
			throw {code: e.code || -1, message: e.message || "An unexpected error occurred."};
		}
}
}

/* ============ End Queries ============ */

/* ============ Mutations ============ */

export class ZetroMutation<T = unknown> {
	private state_: any[] = [];
	private parsers_: ((returnObject: any, item: any) => void)[] = [];
	private readonly client_: IZetroClient;

	constructor(client: IZetroClient) {
		this.client_ = client;
	}

	sendMessage(requestBody: SendMessageRequest): ZetroMutation<T & {sendMessage: number}> {
		this.state_.push(["89dG-t_0BkXmKSZq7mRDCYHXbBo", serializeSendMessageRequest(requestBody)]);
		this.parsers_.push(function (resultObj: any, item: any) {
			resultObj.sendMessage = item[1];
		})
		return this as any;
	}

/*
 * Excecutes the request and returns the response.
 * If the call was unsuccessful, an error of type ZetroServerError
 * will be thrown.
 */
	async fetch(): Promise<T> {
		try {
			const result = await this.client_.makeRequest([2, this.state_]);
			if (result[1] != null) {
				// Error
				throw {code: result[1][0], message: result[1][1]}
			}
			const data = result[0];
			const returnObject = {};
			for (let i = 0; i < data.length; i++) {
				this.parsers_[i](returnObject, data[i]);
			}
			return returnObject as any;
		} catch (e) {
			throw {code: e.code || -1, message: e.message || "An unexpected error occurred."};
		}
}
}

/* ============ End Mutations ============ */