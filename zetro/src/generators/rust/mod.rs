use convert_case::{Case, Casing};

use crate::common::schema::{
    fields::FieldKind, fields::ZetroField, structs::ZetroStruct, ZetroSchema,
};

mod generate_enums;
mod generate_structs;
mod plugins;
mod utilities;

/// Generates schema [de/ser]ialization code for Rust.
pub(crate) fn generate_schema_code(
    mut schema: ZetroSchema,
    args: &crate::utilities::ZetroArgs,
) -> Result<String, String> {
    if args.mangle.is_some() {
        return Err(String::from(
            "The `mangle` option is not supported for Rust. Please run without the option.",
        ));
    }

    let mut scope: Vec<String> = Vec::new();

    // Add global imports and annotations
    scope.push(format!(
        "{}\n{}\n",
        "#![allow(dead_code)]\nuse warp::Filter;",
        if args.untagged {
            "use serde::ser::SerializeTuple;"
        } else {
            ""
        }
    ));

    rustify_schema(&mut schema, &args.field_casing);
    generate_zetro_specific(&mut scope, args.untagged);

    generate_structs::generate_structs(&mut scope, &schema.structs, args.untagged);
    generate_enums::generate_enums(&mut scope, &schema.enums);

    for plugin in &args.plugins {
        match plugin.name.as_str() {
            "warp" => {
                plugins::warp::warp(plugin, &mut scope, &schema.queries, &schema.mutations);
            }
            _ => return Err(format!("Unrecognized plugin: '{}'", plugin.name)),
        }
    }

    // Until we are able to remove unused [de]serializers, etc. We have to
    // allow dead code to avoid warnings.
    // Codegen does not provide a way to add global annotations, so we simply
    // concatenate it to the scope
    Ok(format!(
        "// This is an autogenerated file. DO NOT EDIT\n\n{}",
        scope.join("\n\n")
    ))
}

/// "Rustify" the property names in schema:
/// - Structs will be PascalCased
/// - Enums will be PascalCased
/// - Field names will be snake_cased
fn rustify_schema(schema: &mut ZetroSchema, field_casing: &Option<Case>) {
    let field_casing = match field_casing {
        Some(v) => v.clone(),
        None => Case::Snake,
    };

    // Structs
    for _struct in &mut schema.structs {
        // Notice that we only change case of top-level structs.
        // This is because nested structs will be of the type
        // {ParentStructName}_{FieldName} and we don't want to undo that
        _struct.name = _struct.name.to_case(Case::Pascal);
        rustify_struct(_struct, field_casing);
    }
    // Enums
    for _enum in &mut schema.enums {
        _enum.name = _enum.name.to_case(Case::Pascal);
        for variant in &mut _enum.variants {
            *variant = variant.to_case(Case::Pascal);
        }
    }

    let process_field = |field: &mut ZetroField| rustify_field(field, field_casing);

    // Routes. Notice we don't alter route names.
    // This is because the route name is used to identify a particular route,
    // and changing its case would invalidate references to it in other
    // languages.
    // Queries
    for route in &mut schema.queries {
        process_field(&mut route.request_body);
        process_field(&mut route.response_body);
    }
    // Mutations
    for route in &mut schema.mutations {
        process_field(&mut route.request_body);
        process_field(&mut route.response_body);
    }
}

fn rustify_struct(_struct: &mut ZetroStruct, field_casing: Case) {
    for field in &mut _struct.fields {
        rustify_field(field, field_casing);
    }
}

fn rustify_field(field: &mut ZetroField, field_casing: Case) {
    field.name = field.name.to_case(Case::Snake);

    // Also rename the identifiers in field
    match &mut field.kind {
        FieldKind::StructValue(struct_name) => {
            *struct_name = struct_name.to_case(Case::Pascal);
        }
        FieldKind::EnumValue(enum_name) => {
            *enum_name = enum_name.to_case(Case::Pascal);
        }
        FieldKind::NestedObject(nested) => {
            rustify_struct(nested, field_casing);
        }
        _ => {
            // Primitives have nothing (inside them) to rename.
        }
    }
}

/// Generate some zetro-specific structs such as ZetroServerError
fn generate_zetro_specific(scope: &mut Vec<String>, untagged_repr: bool) {
    // ZetroServerError
    let zetro_server_error = ZetroStruct {
        name: String::from("ZetroServerError"),
        description: String::from("AUTOGENERATED. The struct that serializes error states"),
        is_nullable: false,
        is_multiple: false,
        fields: vec![
            ZetroField {
                description: Some(String::from(
                    "Arbitrary, human-readable message for the end user",
                )),
                kind: FieldKind::StringValue,
                name: String::from("message"),
                is_multiple: false,
                is_nullable: false,
                is_recursive: false,
            },
            ZetroField {
                description: Some(String::from("Arbitrary, response code for frontend logic")),
                kind: FieldKind::Int16,
                name: String::from("code"),
                is_multiple: false,
                is_nullable: false,
                is_recursive: false,
            },
        ],
    };
    scope.push(
        generate_structs::generate_struct(&zetro_server_error, untagged_repr)
            .pop()
            .unwrap(),
    );
    // Make the struct implement warp::reject::Reject (marker trait)
    // so warp::reject::custom() works
    scope.push(String::from(
        "impl warp::reject::Reject for ZetroServerError {}",
    ));
}
