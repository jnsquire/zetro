use crate::common::schema::{
    fields::FieldKind, fields::ZetroField, structs::ZetroStruct, ZetroSchema,
};
use convert_case::{Case, Casing};

mod generate_enums;
mod generate_structs;
mod plugins;
mod utilities;

/// Generates schema [de/ser]ialization code for TypeScript
pub(crate) fn generate_schema_code(
    mut schema: ZetroSchema,
    args: &crate::utilities::ZetroArgs,
) -> Result<String, String> {
    let mut scope: Vec<String> = Vec::new();
    let should_mangle = args.mangle.unwrap_or(false);

    tsify_schema(&mut schema, &args.field_casing, should_mangle);
    generate_zetro_specific(&mut scope, should_mangle);

    generate_structs::generate_structs(&mut scope, &schema.structs, args.untagged);
    generate_enums::generate_enums(&mut scope, &schema.enums);

    for plugin in &args.plugins {
        match plugin.name.as_str() {
            "class-client" => {
                plugins::class_client::class_client(
                    &mut scope,
                    &schema.queries,
                    &schema.mutations,
                    args.untagged,
                    should_mangle,
                );
            }
            _ => return Err(format!("Unrecognized plugin: '{}'", plugin.name)),
        }
    }

    return Ok(format!(
        "// This is an autogenerated file. DO NOT EDIT\n\n{}",
        scope.join("\n\n")
    ));
}

/// "TypeScript-ify" the property names in schema:
/// - Structs will be correctly cased
/// - Enums will be UpperSnaked and an underscore will be appended
/// - Field names will be camelCased and an underscore will be appended
fn tsify_schema(schema: &mut ZetroSchema, field_casing: &Option<Case>, should_mangle: bool) {
    let field_casing = match field_casing {
        Some(v) => v.clone(),
        None => Case::Camel,
    };

    // Structs
    for _struct in &mut schema.structs {
        // Notice that we only change case of top-level structs.
        // This is because nested structs will be of the type
        // {ParentStructName}_{fieldName} and we don't want to undo that
        _struct.name = _struct.name.to_case(Case::Pascal);
        tsify_struct(_struct, field_casing, should_mangle);
    }
    // Enums
    for _enum in &mut schema.enums {
        _enum.name = _enum.name.to_case(Case::Pascal);
        for variant in &mut _enum.variants {
            *variant = format!(
                "{}{}",
                variant.to_case(Case::UpperSnake),
                if should_mangle { "_" } else { "" }
            );
        }
    }

    let process_field = |field: &mut ZetroField| tsify_field(field, field_casing, should_mangle);

    // Routes. Notice we don't alter route names.
    // This is because the route name is used to identify a particular route,
    // and changing its case would invalidate references to it in other
    // languages.
    // Queries
    for route in &mut schema.queries {
        process_field(&mut route.request_body);
        process_field(&mut route.response_body);
    }
    // Mutations
    for route in &mut schema.mutations {
        process_field(&mut route.request_body);
        process_field(&mut route.response_body);
    }
}

fn tsify_struct(_struct: &mut ZetroStruct, casing: Case, should_mangle: bool) {
    for field in &mut _struct.fields {
        tsify_field(field, casing, should_mangle);
    }
}

fn tsify_field(field: &mut ZetroField, casing: Case, should_mangle: bool) {
    field.name = format!(
        "{}{}",
        field.name.to_case(casing),
        if should_mangle { "_" } else { "" }
    );

    // Also rename the identifiers in field
    match &mut field.kind {
        FieldKind::StructValue(struct_name) => {
            *struct_name = struct_name.to_case(Case::Pascal);
        }
        FieldKind::EnumValue(enum_name) => {
            *enum_name = enum_name.to_case(Case::Pascal);
        }
        FieldKind::NestedObject(nested) => {
            tsify_struct(nested, casing, should_mangle);
        }
        _ => {
            // Primitives have nothing (inside them) to rename.
        }
    }
}

/// Generate some zetro-specific structs such as ZetroServerError
fn generate_zetro_specific(scope: &mut Vec<String>, should_mangle: bool) {
    // ZetroServerError
    let zetro_server_error = ZetroStruct {
        name: String::from("ZetroServerError"),
        description: String::from("AUTOGENERATED\nThe struct that serializes error states"),
        is_nullable: false,
        is_multiple: false,
        fields: vec![
            ZetroField {
                description: Some(String::from(
                    "Arbitrary, human-readable message for the end user",
                )),
                kind: FieldKind::StringValue,
                name: format!("message{}", if should_mangle { "_" } else { "" }),
                is_multiple: false,
                is_nullable: false,
                is_recursive: false,
            },
            ZetroField {
                description: Some(String::from("Arbitrary, response code for frontend logic")),
                kind: FieldKind::Int16,
                name: format!("code{}", if should_mangle { "_" } else { "" }),
                is_multiple: false,
                is_nullable: false,
                is_recursive: false,
            },
        ],
    };
    scope.push(
        generate_structs::generate_interface(&zetro_server_error, true)
            .pop()
            .unwrap(),
    );
}
